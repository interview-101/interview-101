# TCP 建立连接 为什么是三次握手？

第一次：client -> server，你能收到我的消息吗？

第二次：client <- server，能收到，你能收到我的消息吗？

第三次：client -> server，我也能收到你的消息

信道不可靠，至少需要三次握手来确保信道是**"可用的"**，**确保双方能收能发**


## 为什么一定要三次握手？两次握手就不行呢？为什么三次就是可靠的呢？
![](https://haitao.nos.netease.com/e01a894b-c39d-44aa-af6c-274182db37c6_822_424.png)

假设客户端与服务端直接只有两次握手，客户端第一次发送连接的请求因为网络原因在网络结点中发生了滞留（没有丢失）；此时客户端因为没有收到确认报文，又发了第二个连接的请求（syn），此时服务端发送了（ack+syn）表回复确认收到；如果是两次，此时开始传输数据，数据发送完关闭连接。  

此时网络通畅了，第一个滞留的请求到了服务端，服务端进行了回复（ack+syn），如果只有两次握手的话，又开始了客户端和服务端之间的连接建立，但这是没必要的，造成了错误与浪费。  

所以如果有三次握手的话，就算服务端发出了收到的确认回复，客户端也不会再发出ack的确认标记，服务端就知道原来客户端没有要建立连接，所以之前滞留的请求就不会再创建连接了，也就避免了资源浪费。


# TCP 释放连接 为什么是四次挥手

前两次用来释放 client -> server 方向的连接

后两次用来释放 client <- server 方向的连接

## 为什么是四次挥手？多了的一次挥手相比于握手多在了哪里呢？
![](https://haitao.nos.netease.com/18d1353c-b18a-4bc8-9ae6-eb7ff67e34dd_797_473.png)

先看下过程
* step1:
  客户端向服务端发出 FIN+seq 标记，表示客户端要主动关闭连接，停止发送数据
* step2:
  服务端发出 ACK + seq标记，发出确认回复的报文，此时，服务端进入**半关闭状态**（客户端已经没有数据发出了，但服务端若发出数据，客户端要接收）**因为此时服务端的数据不一定完全发送完了**
* step3:
  服务端最后的数据发送完了，就像客户端发送FIN+ACK 连接释放的报文, 服务器此时进入了等待客户端最后确认的状态
* step4:
  客户端收到服务端连接释放的报文后，发出ACK+seq表示确认，服务器收到了客户端发出的确认报文猴就立即进入了closed状态

所以可以看出，挥手多的一个步骤是在step3, ACK 和 FIN 在服务端分成了2步发出，如果服务端再收到客户端发来的FIN报文后，如果没有数据传输了，那么FIN+ACK是可以合并的

> 参考资料：
> 1. [TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)
> 2. [《图解http》](https://www.amazon.cn/dp/B00JTQK1L4)
> 3. [cs50-tcp](https://www.youtube.com/watch?v=GP7uvI_6uas&t=1s)
> 4. [cs50-http](https://www.youtube.com/watch?v=4axL8Gfw2nI)


# 介绍下 HTTP/2 的一些新特性

- 采用了二进制格式传输数据（相比 HTTP/1.x 的文本格式）
- 多路复用
- header 压缩
- 服务器推送

# HTTP/2 多路复用？

同一个域名下，多个请求可以复用同一个 TCP 连接

# HTTP/2 服务器推送（Server Push）？

服务器发送 HTML 后，需要等待浏览器解析 HTML 后发起内嵌资源的请求，才会响应 JavaScript、CSS、images 等资源，Server Push 允许服务器提前推送这些资源到浏览器的缓存中，消除了中间的等待时间

> 参考 [HTTP/2 FAQ](https://http2.github.io/faq/)
